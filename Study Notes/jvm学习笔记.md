# jvm 笔记
## G1垃圾回收器
### 一、G1出现的契机
#### 1、吞吐量
- 吞吐量关注的是，在一个指定的时间内，最大化应用的工作量。
- 如下方式来衡量一个系统吞吐量的好坏
 - 在一小时内同一个事务（或者任务、请求）完成的次数（tps）
 - 数据库一小时可以完成多少次查询
- 对于关注吞吐量的系统，卡顿是可以接受的，因为这个系统关注长时间的大量任务的执行能力单次快速的响应并不值得考虑。

#### 2、 响应能力
- 响应能力指一个程序或者系统对请求是否能够及时响应，比如:
 - 一个桌面UI能多快地响应一个事件
 - 一个网站能够多快返回
 - 一个页面请求数据库能够多快返回查询的数据
- 对于这类对响应能力敏感的场景，长时间的停顿是无法接受的

#### 3、G1概念
- G1 收集器是一个面向服务端的垃圾收集器，适用于多核处理器、大内存容量的服务端。
- 它满足短时间 gc 停顿的同时达到一个较高的吞吐量。
- JDK7 以上版本适用。

#### 4、G1 收集器的设计目标
- 与应用线程同时工作，几乎不需要 stop the Word（与 CMS 类似）；
- 整理剩余空间，不产生内存碎片（CMS 只能在 Ful GC 时，用 stop the world 整理内存碎片 
- GC 停顿更加可控
- 不牺牲系统的吞吐量
- gc 不要求额外的内存空间（CMS 需要预留空间存储**浮动垃圾**）

#### 5、 G1 的设计规划是要替换掉 CMS

- G1 在某些方面弥补了 CMS 的不足，比如 CMS 使用的是 **mark-sweep**算法，自然会产生内存碎片；然而G1基于 **copying** 算法，高效的整理剩余内存，而不需要管理内存碎片。
- 另外，G1 提供了更多手段，以达到对 gc 停顿时间的可控。

### 二、G1堆空间结构
#### 1、hotspot 虚拟机构成
![-w797](media/15793404293959.jpg)
#### 2、传统垃圾收集器堆机构
![-w794](media/15793405811513.jpg)
#### 3、G1收集器堆结构
![-w796](media/15793407139038.jpg)
- Heap 被划分为一个个相等的不连续的内存区域（regions），每个 region 都有代的角色：eden、survor、old
- 对每个角色的数量并没有强制的限定，也就是说对每种分代内存的大小，可以动态变化
- G1 最大的特点就是高效的执行回收，优先去执行那些大量对象可回收的区域（region)
- G1 使用了 gc 停顿可预测的模型，来满足用户设定的 gc 停顿时间，根据用户设定的目标时间，G1 会自动地选择哪些 region 要清除，一次清除多少个region
- G1 从多个 region 中复制存活的对象，然后集中放入一个 region 中，同时整理、清除内存（**copying 收集算法**）

#### 4、G1 vs CMS
- 对比使用 mark-sweep 的 CMS, G1 使用的 copying 算法**不会造成内存碎片**;
- 对比 Parallel Scavenge（基于copying) Parallel Old 收集器（基于 mark-compact-sweep), Parallel 会对整个区域做整理**导致 gc 停顿会比较长**，而 G1 只是特定地整理几region；
- G1 并非一个实时的收集器，与 parallel Scavenge 一样，对 gc 停顿时间的设置并**不绝对生效**，只是 G1 有较高的几率保证不超过设定的 gc 停顿时间。与之前的 gc 收集器对比，G1 会根据用户设定的 gc 停顿时间智能评估哪几个 region 需要被回收可以满足用户的设定；

#### 5、G1重要的概念
- 分区（Region): G1采取了不同的策略来解决并行、串行和 CMS 收集器的碎片、暂停时间不可控等问题，G1将**整个堆分**成相同大小的分区（Region)；
- 每个分区都**可能是年轻代也可能是老年代**，但是在同一时刻只能属于某个代。年轻代、幸存区老年代这些概念还存在，成为**逻辑上的概念**，这样方便复用之前分代框架的逻辑。
- 在物理上不需要连续，则带来了额外的好处有的分区内垃圾对象特别多，有的分区内垃圾对象很少，**G1 会优先回收垃圾对象特别多的分区**这样可以花费较少的时间来回收这些分区的垃圾这也就是 G1 名字的由来，即首先收集垃圾最多的