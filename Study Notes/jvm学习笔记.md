# jvm 笔记
## G1垃圾回收器
### 一、G1出现的契机
#### 1、吞吐量
- 吞吐量关注的是，在一个指定的时间内，最大化应用的工作量。
- 如下方式来衡量一个系统吞吐量的好坏
 - 在一小时内同一个事务（或者任务、请求）完成的次数（tps）
 - 数据库一小时可以完成多少次查询
- 对于关注吞吐量的系统，卡顿是可以接受的，因为这个系统关注长时间的大量任务的执行能力单次快速的响应并不值得考虑。

#### 2、 响应能力
- 响应能力指一个程序或者系统对请求是否能够及时响应，比如:
 - 一个桌面UI能多快地响应一个事件
 - 一个网站能够多快返回
 - 一个页面请求数据库能够多快返回查询的数据
- 对于这类对响应能力敏感的场景，长时间的停顿是无法接受的

#### 3、G1概念
- G1 收集器是一个面向服务端的垃圾收集器，适用于多核处理器、大内存容量的服务端。
- 它满足短时间 gc 停顿的同时达到一个较高的吞吐量。
- JDK7 以上版本适用。

#### 4、G1 收集器的设计目标
- 与应用线程同时工作，几乎不需要 stop the Word（与 CMS 类似）；
- 整理剩余空间，不产生内存碎片（CMS 只能在 Ful GC 时，用 stop the world 整理内存碎片 
- GC 停顿更加可控
- 不牺牲系统的吞吐量
- gc 不要求额外的内存空间（CMS 需要预留空间存储**浮动垃圾**）

#### 5、 G1 的设计规划是要替换掉 CMS

- G1 在某些方面弥补了 CMS 的不足，比如 CMS 使用的是 **mark-sweep**算法，自然会产生内存碎片；然而G1基于 **copying** 算法，高效的整理剩余内存，而不需要管理内存碎片。
- 另外，G1 提供了更多手段，以达到对 gc 停顿时间的可控。

### 二、G1堆空间结构
#### 1、hotspot 虚拟机构成
![-w797](media/15793404293959.jpg)
#### 2、传统垃圾收集器堆机构
![-w794](media/15793405811513.jpg)
#### 3、G1收集器堆结构
![-w796](media/15793407139038.jpg)
- Heap 被划分为一个个相等的不连续的内存区域（regions），每个 region 都有代的角色：eden、survor、old
- 对每个角色的数量并没有强制的限定，也就是说对每种分代内存的大小，可以动态变化
- G1 最大的特点就是高效的执行回收，优先去执行那些大量对象可回收的区域（region)
- G1 使用了 gc 停顿可预测的模型，来满足用户设定的 gc 停顿时间，根据用户设定的目标时间，G1 会自动地选择哪些 region 要清除，一次清除多少个region
- G1 从多个 region 中复制存活的对象，然后集中放入一个 region 中，同时整理、清除内存（**copying 收集算法**）

#### 4、G1 vs CMS
- 对比使用 mark-sweep 的 CMS, G1 使用的 copying 算法**不会造成内存碎片**;
- 对比 Parallel Scavenge（基于copying) Parallel Old 收集器（基于 mark-compact-sweep), Parallel 会对整个区域做整理**导致 gc 停顿会比较长**，而 G1 只是特定地整理几region；
- G1 并非一个实时的收集器，与 parallel Scavenge 一样，对 gc 停顿时间的设置并**不绝对生效**，只是 G1 有较高的几率保证不超过设定的 gc 停顿时间。与之前的 gc 收集器对比，G1 会根据用户设定的 gc 停顿时间智能评估哪几个 region 需要被回收可以满足用户的设定；

#### 5、G1重要的概念
- 分区（Region):
    - G1采取了不同的策略来解决并行、串行和 CMS 收集器的碎片、暂停时间不可控等问题，G1将**整个堆分**成相同大小的分区（Region)；
    - 每个分区都**可能是年轻代也可能是老年代**，但是在同一时刻只能属于某个代。年轻代、幸存区老年代这些概念还存在，成为**逻辑上的概念**，这样方便复用之前分代框架的逻辑。
    - 在物理上不需要连续，则带来了额外的好处有的分区内垃圾对象特别多，有的分区内垃圾对象很少，**G1 会优先回收垃圾对象特别多的分区**这样可以花费较少的时间来回收这些分区的垃圾这也就是 G1 名字的由来，即首先收集垃圾最多的
    - 依然是在新生代满了的时候，对整个新生代进行回收一一整个新生代中的对象，要么被回收、要么晋升，至于新生代也采取分区机制的原因，**则是因为这样跟老年代的策略统一，方便调整代的大小**
    - G1 还是一种带压缩的收集器，在回收老年代的分区时，是将存活的对象从一个分区拷贝到另一个可用分区，这个拷贝的过程就**实现了局部的压缩**。

- 收集集合(CSet）：
	- **一组可被回收的分区的集合**。在CSet中存活的数据会在GC过程中被移动到另一个可用分区，CSet中的分区可以来自**eden空间、survor空间或者老年代。**	   
- 已记忆集合（RSet): 
 - RSet 记录了**其他 Region 中的对象引用本 Region 中对象的关系**，属于 points-into？结构（谁引用了我的对象）。RSet 的价值在于使得垃圾收集器不需要扫描整个堆找到谁引用了当前分区中的对象，只需要扫描 RSet 即可。  
 - Region1 和 Region3 中的对象都引用了 Region2 中的对象，因此在 Region2 的 RSet 中记录了这两个引用。
![](media/15800487262330.jpg)
- G1 GC 是在 points-out 的 card table 之上再加了一层结构来构成 points- into Rset：每个 region 会记录下到底哪些别的 region 有指向自己的指针，而这些指针分别在哪些 card 的范围内。
- 这个 RSet 其实是一个 hash table, key 是别的 Regions 的起始地址，value 是一个集合，里面的元素是 card tablel 的 Index。举例来说，如果 region A 的 RSet 里有一项的 key 是 region B value 里有index为1234的card，它的意思就是 region B的card 里有引用指向region A。所以对region A来说该RSet记录的是points-into的关系；而card table仍然记录points-out的关系。
- Snapshot-at-the-beginning (SATB) SATB 是 G1 GC 在**并发标记阶段**使用的**增量式**的标记算法。
- 并发标记是并发多线程的，但并发线程在同一时刻只扫描一个分区；

#### 6、G1 和 CMS 对比
- G1 在压缩空间方面有优势（cms标记清除，g1是copy算法）
- G1 通过将内存空间分成区域（Region）的方式避免内存碎片问题
- Eden、Survivor、Old 区不再固定，在内存使用效率上来说更灵活
- G1 可以通过设置预期停顿时间（Pause Time）来控制垃圾收集时间，避免应用雪崩现象
- G1 在回收内存后会马上同时做合并空闲内存的工作，而 CMS 默认是在 STW (stop the world）的时候做 G1 会在 Young GC 中使用，而 CMS 只能在 Old 区使用